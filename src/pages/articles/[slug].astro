---
/**
 * Page Article individuel - Détail d'un article
 *
 * Route dynamique : /articles/[slug]
 *
 * Adapté du template original astro-erudite pour Hashnode.
 * Layout: TOC à gauche, contenu à droite (comme le template original)
 */

import Breadcrumbs from "@/components/Breadcrumbs.astro";
import Link from "@/components/Link.astro";
import PageHead from "@/components/PageHead.astro";
import PostNavigation from "@/components/PostNavigation.astro";
import SeriesNavCard from "@/components/SeriesNavCard.astro";
import TOCHeader from "@/components/TOCHeader.astro";
import TOCSidebar from "@/components/TOCSidebar.astro";
import { badgeVariants } from "@/components/ui/badge";
import Layout from "@/layouts/Layout.astro";
import { Icon } from "astro-icon/components";

// Import des fonctions API Hashnode
import {
	getAllPosts,
	getPostBySlug,
	getSeriesBySlug,
	formatDate,
	extractHeadingsFromHtml,
	getAdjacentPosts,
} from "@/lib/hashnode/api";
import type { Post, Series } from "@/lib/hashnode/types";

// Génère toutes les routes possibles au moment du build
export async function getStaticPaths() {
	const allPosts = await getAllPosts(50); // Limite API: 50 max

	return allPosts.map((post) => ({
		params: { slug: post.slug },
		props: { post },
	}));
}

const { slug } = Astro.params;
const { post: initialPost } = Astro.props as { post: Post };

// Récupère les détails complets de l'article (avec le contenu HTML)
let post: Post | null = null;

try {
	post = await getPostBySlug(slug as string);

	// Si getPostBySlug retourne null, utiliser initialPost comme fallback
	if (!post && initialPost) {
		console.log(
			`[Article Page] getPostBySlug returned null for "${slug}", using initialPost as fallback`,
		);
		post = initialPost;
	}
} catch (error) {
	console.error(
		`Erreur lors de la récupération de l'article "${slug}":`,
		error,
	);
	post = initialPost;
}

// Récupère les articles adjacents pour la navigation Previous/Next
const { older, newer } = await getAdjacentPosts(slug as string);

// Récupère les données complètes de la série si l'article appartient à une série
let seriesData: Series | null = null;
if (post?.series?.slug) {
	try {
		seriesData = await getSeriesBySlug(post.series.slug);
	} catch (error) {
		console.error(
			`Erreur lors de la récupération de la série "${post.series.slug}":`,
			error,
		);
	}
}

// Formatage de la date
const publishedDate = post ? formatDate(post.publishedAt) : "";

// Extraction des headings pour la TOC
const headings = post?.content?.html
	? extractHeadingsFromHtml(post.content.html)
	: [];

// Breadcrumbs avec icônes (comme le template original)
const breadcrumbItems = [
	{ label: "Articles", href: "/articles", icon: "lucide:library-big" },
	{ label: post?.title || "Article", icon: "lucide:book-open-text" },
];
---

<Layout>
  <PageHead
    slot="head"
    title={post?.title || 'Article'}
    description={post?.brief || 'Un article'}
  />

  <!-- TOC Mobile (affiché dans le header sticky) -->
  {headings.length > 0 && (
    <TOCHeader headings={headings} slot="table-of-contents" />
  )}

  {post ? (
    <section
      class="grid grid-cols-[minmax(0px,1fr)_min(calc(var(--breakpoint-md)-2rem),100%)_minmax(0px,1fr)] gap-y-6"
    >
      <!-- Breadcrumbs -->
      <div class="col-start-2">
        <Breadcrumbs items={breadcrumbItems} />
      </div>

      <!-- Image de couverture -->
      {post.coverImage && (
        <img
          src={post.coverImage.url}
          alt={post.title}
          class="col-start-2 w-full rounded-lg object-cover max-h-80"
        />
      )}

      <!-- Header de l'article (centré) -->
      <section class="col-start-2 flex flex-col gap-y-6 text-center">
        <div class="flex flex-col">
          <!-- Série (si l'article appartient à une série) -->
          {post.series && (
            <Link
              href={`/series/${post.series.slug}`}
              class="inline-flex items-center justify-center gap-1.5 text-sm text-primary hover:underline mb-2"
            >
              <Icon name="lucide:layers" class="size-4" />
              {post.series.name}
            </Link>
          )}

          <!-- Titre -->
          <h1
            class="mb-2 scroll-mt-31 text-3xl leading-tight font-medium sm:text-4xl"
            id="post-title"
          >
            {post.title}
          </h1>

          <!-- Métadonnées -->
          <div
            class="text-muted-foreground divide-border mb-4 flex flex-col items-center justify-center divide-y text-xs sm:flex-row sm:flex-wrap sm:divide-x sm:divide-y-0 sm:text-sm"
          >
            <div class="flex w-full items-center justify-center gap-2 py-2 sm:w-fit sm:px-2 sm:py-0 first:sm:pl-0 last:sm:pr-0">
              <span>{publishedDate}</span>
            </div>

            <div class="flex w-full items-center justify-center gap-2 py-2 sm:w-fit sm:px-2 sm:py-0 first:sm:pl-0 last:sm:pr-0">
              <span>{post.readTimeInMinutes} min read</span>
            </div>
          </div>

          <!-- Tags -->
          {post.tags && post.tags.length > 0 && (
            <div class="flex flex-wrap justify-center gap-2">
              {post.tags.map((tag) => (
                <a
                  href={`/tags/${tag.slug}`}
                  class={badgeVariants({ variant: 'muted' })}
                >
                  <Icon name="lucide:hash" class="size-3" />
                  {tag.name}
                </a>
              ))}
            </div>
          )}
        </div>

        <!-- Navigation Previous/Next Post -->
        <PostNavigation
          newerPost={newer ? { title: newer.title, slug: newer.slug } : undefined}
          olderPost={older ? { title: older.title, slug: older.slug } : undefined}
        />
      </section>

      <!-- Wrapper pour TOC + Contenu (toujours alignés) -->
      <div class="col-span-full grid grid-cols-[minmax(0px,1fr)_min(calc(var(--breakpoint-md)-2rem),100%)_minmax(0px,1fr)]">
        <!-- TOC Sidebar pour desktop (à gauche, proche du contenu) -->
        {headings.length > 0 && (
          <div class="col-start-1 flex justify-end pr-12">
            <TOCSidebar headings={headings} />
          </div>
        )}

        <!-- Contenu de l'article -->
        <article class="prose col-start-2 max-w-none dark:prose-invert">
          {post.content?.html ? (
            <Fragment set:html={post.content.html} />
          ) : (
            <p class="text-muted-foreground">Contenu non disponible.</p>
          )}

          <!-- Carte de navigation de série (uniquement si l'article appartient à une série) -->
          {seriesData && seriesData.posts?.edges && (
            <SeriesNavCard
              seriesName={seriesData.name}
              seriesSlug={seriesData.slug}
              seriesDescription={seriesData.description?.text}
              posts={seriesData.posts.edges.map(edge => edge.node)}
              currentSlug={slug as string}
            />
          )}
        </article>
      </div>

      <!-- Navigation Previous/Next Post (fin de l'article) -->
      <div class="col-start-2">
        <PostNavigation
          newerPost={newer ? { title: newer.title, slug: newer.slug } : undefined}
          olderPost={older ? { title: older.title, slug: older.slug } : undefined}
        />
      </div>
    </section>
  ) : (
    <!-- Article non trouvé -->
    <section class="py-12 text-center">
      <Icon name="lucide:alert-circle" class="size-12 text-muted-foreground/50 mx-auto mb-4" />
      <h1 class="text-2xl font-bold mb-2">Article non trouvé</h1>
      <p class="text-muted-foreground mb-6">
        L'article que vous recherchez n'existe pas ou a été supprimé.
      </p>
      <Link
        href="/articles"
        class="text-primary hover:underline flex items-center justify-center gap-2"
      >
        <Icon name="lucide:arrow-left" class="size-4" />
        Retour aux articles
      </Link>
    </section>
  )}
</Layout>
